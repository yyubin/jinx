---
sidebar_position: 1
---

# ìƒˆë¡œìš´ ë°ì´í„°ë² ì´ìŠ¤ ë°©ì–¸ ì¶”ê°€í•˜ê¸°

> ğŸ“– **Read this guide in English**: Switch to EN locale using the language dropdown

ì´ ê°€ì´ë“œëŠ” Jinxì— ìƒˆë¡œìš´ ë°ì´í„°ë² ì´ìŠ¤ ë°©ì–¸ì„ ì¶”ê°€í•˜ëŠ” ë°©ë²•ì„ ë‹¨ê³„ë³„ë¡œ ì„¤ëª…í•©ë‹ˆë‹¤. JinxëŠ” í™•ì¥ ê°€ëŠ¥í•œ SPI(Service Provider Interface) ê¸°ë°˜ ì•„í‚¤í…ì²˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ë‹¤ì–‘í•œ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ ì§€ì›í•©ë‹ˆë‹¤.

## ëª©ì°¨

1. [ë°©ì–¸ ì•„í‚¤í…ì²˜ ê°œìš”](#ë°©ì–¸-ì•„í‚¤í…ì²˜-ê°œìš”)
2. [ë‹¨ê³„ë³„ êµ¬í˜„ ê°€ì´ë“œ](#ë‹¨ê³„ë³„-êµ¬í˜„-ê°€ì´ë“œ)
3. [SPI ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„](#spi-ì¸í„°í˜ì´ìŠ¤-êµ¬í˜„)
4. [ë°©ì–¸ ë²ˆë“¤ êµ¬ì„±](#ë°©ì–¸-ë²ˆë“¤-êµ¬ì„±)
5. [VisitorFactory ë“±ë¡](#visitorfactory-ë“±ë¡)
6. [CLI í†µí•©](#cli-í†µí•©)
7. [í…ŒìŠ¤íŠ¸ ì‘ì„±](#í…ŒìŠ¤íŠ¸-ì‘ì„±)
8. [ì‹¤ì œ ì˜ˆì‹œ: PostgreSQL ë°©ì–¸ ì¶”ê°€](#ì‹¤ì œ-ì˜ˆì‹œ-postgresql-ë°©ì–¸-ì¶”ê°€)

## ë°©ì–¸ ì•„í‚¤í…ì²˜ ê°œìš”

### í•µì‹¬ ì»´í¬ë„ŒíŠ¸

Jinxì˜ ë°©ì–¸ ì‹œìŠ¤í…œì€ ë‹¤ìŒê³¼ ê°™ì€ ê³„ì¸µìœ¼ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤:

```
DialectBundle
â”œâ”€â”€ BaseDialect (ê¸°ë³¸ ì‹ë³„ì ì²˜ë¦¬)
â”œâ”€â”€ DdlDialect (DDL ìƒì„±)
â”œâ”€â”€ IdentityDialect (AUTO_INCREMENT ë“±)
â”œâ”€â”€ SequenceDialect (ì‹œí€€ìŠ¤ ì§€ì›)
â”œâ”€â”€ TableGeneratorDialect (í…Œì´ë¸” ê¸°ë°˜ ID ìƒì„±)
â””â”€â”€ LiquibaseDialect (Liquibase ì¶œë ¥)
```

### SPI ì¸í„°í˜ì´ìŠ¤

```java
// ê¸°ë³¸ ì •ì±…
public interface IdentifierPolicy {
    int maxLength();              // ì‹ë³„ì ìµœëŒ€ ê¸¸ì´ (30, 63, 64, 128 ë“±)
    String quote(String raw);     // ì‹ë³„ì ì¸ìš© (`foo`, "foo", [foo])
    String normalizeCase(String raw);  // ëŒ€ì†Œë¬¸ì ì •ê·œí™” (Oracle â†’ toUpperCase)
    boolean isKeyword(String raw);     // ì˜ˆì•½ì–´ í™•ì¸
}

// íƒ€ì… ë§¤í•‘
public interface JavaTypeMapper {
    JavaType map(String className);

    interface JavaType {
        String getSqlType(int length, int precision, int scale);
        boolean needsQuotes();
        String getDefaultValue();
    }
}

// ê°’ ë³€í™˜
public interface ValueTransformer {
    String quote(String value, JavaTypeMapper.JavaType type);
}
```

## ë‹¨ê³„ë³„ êµ¬í˜„ ê°€ì´ë“œ

### 1. íŒ¨í‚¤ì§€ êµ¬ì¡° ìƒì„±

ìƒˆë¡œìš´ ë°©ì–¸ì„ ìœ„í•œ íŒ¨í‚¤ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤:

```
jinx-core/src/main/java/org/jinx/migration/dialect/postgresql/
â”œâ”€â”€ PostgreSqlDialect.java
â”œâ”€â”€ PostgreSqlIdentifierPolicy.java
â”œâ”€â”€ PostgreSqlJavaTypeMapper.java
â”œâ”€â”€ PostgreSqlValueTransformer.java
â”œâ”€â”€ PostgreSqlMigrationVisitor.java
â””â”€â”€ PostgreSqlUtil.java (í•„ìš”ì‹œ)
```

### 2. í…ŒìŠ¤íŠ¸ íŒ¨í‚¤ì§€ êµ¬ì¡°

```
jinx-core/src/test/java/org/jinx/migration/dialect/postgresql/
â”œâ”€â”€ PostgreSqlDialectTest.java
â”œâ”€â”€ PostgreSqlIdentifierPolicyTest.java
â”œâ”€â”€ PostgreSqlJavaTypeMapperTest.java
â”œâ”€â”€ PostgreSqlValueTransformerTest.java
â””â”€â”€ PostgreSqlMigrationVisitorTest.java
```

## SPI ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„

### 1. IdentifierPolicy êµ¬í˜„

```java
package org.jinx.migration.dialect.postgresql;

import org.jinx.migration.spi.IdentifierPolicy;
import java.util.Set;

public class PostgreSqlIdentifierPolicy implements IdentifierPolicy {

    // PostgreSQL ì˜ˆì•½ì–´ ëª©ë¡
    private static final Set<String> KEYWORDS = Set.of(
        "select", "from", "where", "insert", "update", "delete",
        "create", "drop", "alter", "table", "column", "index",
        // ... PostgreSQL ì˜ˆì•½ì–´ë“¤
    );

    @Override
    public int maxLength() {
        return 63; // PostgreSQL identifier limit
    }

    @Override
    public String quote(String raw) {
        if (raw == null || raw.isEmpty()) {
            return raw;
        }
        // PostgreSQLì€ í°ë”°ì˜´í‘œ ì‚¬ìš©
        return "\"" + raw + "\"";
    }

    @Override
    public String normalizeCase(String raw) {
        if (raw == null) return null;
        // PostgreSQLì€ ì†Œë¬¸ìë¡œ ì •ê·œí™” (ëŒ€ì†Œë¬¸ì êµ¬ë¶„í•˜ì§€ ì•ŠìŒ)
        return raw.toLowerCase();
    }

    @Override
    public boolean isKeyword(String raw) {
        return raw != null && KEYWORDS.contains(raw.toLowerCase());
    }
}
```

### 2. JavaTypeMapper êµ¬í˜„

```java
package org.jinx.migration.dialect.postgresql;

import org.jinx.migration.spi.JavaTypeMapper;

public class PostgreSqlJavaTypeMapper implements JavaTypeMapper {

    @Override
    public JavaType map(String className) {
        return switch (className) {
            case "java.lang.String" -> new PostgreSqlStringType();
            case "int", "java.lang.Integer" -> new PostgreSqlIntegerType();
            case "long", "java.lang.Long" -> new PostgreSqlBigIntType();
            case "java.math.BigDecimal" -> new PostgreSqlDecimalType();
            case "boolean", "java.lang.Boolean" -> new PostgreSqlBooleanType();
            case "java.time.LocalDate" -> new PostgreSqlDateType();
            case "java.time.LocalDateTime" -> new PostgreSqlTimestampType();
            case "java.util.UUID" -> new PostgreSqlUuidType();
            case "byte[]" -> new PostgreSqlByteArrayType();
            // ... ê¸°íƒ€ íƒ€ì…ë“¤
            default -> new PostgreSqlStringType(); // ê¸°ë³¸ê°’
        };
    }

    // ë‚´ë¶€ íƒ€ì… í´ë˜ìŠ¤ë“¤
    private static class PostgreSqlStringType implements JavaType {
        @Override
        public String getSqlType(int length, int precision, int scale) {
            return length > 0 ? "VARCHAR(" + length + ")" : "TEXT";
        }

        @Override
        public boolean needsQuotes() { return true; }

        @Override
        public String getDefaultValue() { return null; }
    }

    private static class PostgreSqlIntegerType implements JavaType {
        @Override
        public String getSqlType(int length, int precision, int scale) {
            return "INTEGER";
        }

        @Override
        public boolean needsQuotes() { return false; }

        @Override
        public String getDefaultValue() { return "0"; }
    }

    private static class PostgreSqlBigIntType implements JavaType {
        @Override
        public String getSqlType(int length, int precision, int scale) {
            return "BIGINT";
        }

        @Override
        public boolean needsQuotes() { return false; }

        @Override
        public String getDefaultValue() { return "0"; }
    }

    private static class PostgreSqlUuidType implements JavaType {
        @Override
        public String getSqlType(int length, int precision, int scale) {
            return "UUID";
        }

        @Override
        public boolean needsQuotes() { return false; }

        @Override
        public String getDefaultValue() { return null; }
    }

    // ... ê¸°íƒ€ íƒ€ì… í´ë˜ìŠ¤ë“¤
}
```

### 3. ValueTransformer êµ¬í˜„

```java
package org.jinx.migration.dialect.postgresql;

import org.jinx.migration.spi.JavaTypeMapper;
import org.jinx.migration.spi.ValueTransformer;

public class PostgreSqlValueTransformer implements ValueTransformer {

    @Override
    public String quote(String value, JavaTypeMapper.JavaType type) {
        if (value == null) {
            return "NULL";
        }

        if (type.needsQuotes()) {
            // ë¬¸ìì—´ íƒ€ì…: ì‘ì€ë”°ì˜´í‘œë¡œ ê°ì‹¸ê³  ì´ìŠ¤ì¼€ì´í”„
            return "'" + value.replace("'", "''") + "'";
        } else {
            // ìˆ«ì, ë¶ˆë¦° ë“±: ê·¸ëŒ€ë¡œ ë°˜í™˜
            return value;
        }
    }
}
```

### 4. ë©”ì¸ Dialect í´ë˜ìŠ¤ êµ¬í˜„

```java
package org.jinx.migration.dialect.postgresql;

import org.jinx.migration.AbstractDialect;
import org.jinx.migration.spi.JavaTypeMapper;
import org.jinx.migration.spi.ValueTransformer;
import org.jinx.migration.spi.dialect.*;
import org.jinx.model.*;

public class PostgreSqlDialect extends AbstractDialect
        implements SequenceDialect, LiquibaseDialect {

    public PostgreSqlDialect() {
        super();
    }

    @Override
    protected JavaTypeMapper initializeJavaTypeMapper() {
        return new PostgreSqlJavaTypeMapper();
    }

    @Override
    protected ValueTransformer initializeValueTransformer() {
        return new PostgreSqlValueTransformer();
    }

    // BaseDialect êµ¬í˜„
    @Override
    public String quoteIdentifier(String raw) {
        return "\"" + raw + "\"";
    }

    // DdlDialect êµ¬í˜„
    @Override
    public String openCreateTable(String tableName) {
        return "CREATE TABLE " + quoteIdentifier(tableName) + " (\n";
    }

    @Override
    public String closeCreateTable() {
        return "\n);";
    }

    @Override
    public String getCreateTableSql(EntityModel entity) {
        // CREATE TABLE ë¡œì§ êµ¬í˜„
        // MySQL ì˜ˆì‹œë¥¼ ì°¸ê³ í•˜ì—¬ PostgreSQL ë¬¸ë²•ì— ë§ê²Œ êµ¬í˜„
    }

    @Override
    public String getColumnDefinitionSql(ColumnModel column) {
        StringBuilder sb = new StringBuilder();

        String javaType = column.getConversionClass() != null ?
            column.getConversionClass() : column.getJavaType();
        JavaTypeMapper.JavaType mappedType = javaTypeMapper.map(javaType);

        String sqlType;
        if (column.getSqlTypeOverride() != null && !column.getSqlTypeOverride().trim().isEmpty()) {
            sqlType = column.getSqlTypeOverride().trim();
        } else {
            sqlType = mappedType.getSqlType(column.getLength(), column.getPrecision(), column.getScale());
        }

        sb.append(quoteIdentifier(column.getColumnName())).append(" ").append(sqlType);

        if (!column.isNullable()) {
            sb.append(" NOT NULL");
        }

        // PostgreSQLì€ SERIAL íƒ€ì… ì§€ì›
        if (shouldUseSerial(column.getGenerationStrategy())) {
            // SERIAL íƒ€ì…ì€ ì´ë¯¸ sqlTypeì— í¬í•¨ë¨
        }

        if (column.getDefaultValue() != null) {
            sb.append(" DEFAULT ").append(valueTransformer.quote(column.getDefaultValue(), mappedType));
        }

        return sb.toString();
    }

    // SequenceDialect êµ¬í˜„ (PostgreSQLì€ ì‹œí€€ìŠ¤ ì§€ì›)
    @Override
    public String getCreateSequenceSql(SequenceModel sequence) {
        StringBuilder sb = new StringBuilder();
        sb.append("CREATE SEQUENCE ").append(quoteIdentifier(sequence.getSequenceName()));

        if (sequence.getInitialValue() > 1) {
            sb.append(" START WITH ").append(sequence.getInitialValue());
        }

        if (sequence.getAllocationSize() > 1) {
            sb.append(" INCREMENT BY ").append(sequence.getAllocationSize());
        }

        sb.append(";\n");
        return sb.toString();
    }

    @Override
    public String getDropSequenceSql(SequenceModel sequence) {
        return "DROP SEQUENCE IF EXISTS " + quoteIdentifier(sequence.getSequenceName()) + ";\n";
    }

    @Override
    public String getAlterSequenceSql(SequenceModel newSeq, SequenceModel oldSeq) {
        // PostgreSQL ì‹œí€€ìŠ¤ ë³€ê²½ ë¡œì§
        return "";
    }

    // PostgreSQL íŠ¹í™” ë©”ì„œë“œë“¤
    private boolean shouldUseSerial(GenerationStrategy strategy) {
        return strategy == GenerationStrategy.IDENTITY || strategy == GenerationStrategy.AUTO;
    }

    @Override
    public int getMaxIdentifierLength() {
        return 63; // PostgreSQL limit
    }

    // ... ê¸°íƒ€ DdlDialect ë©”ì„œë“œë“¤ êµ¬í˜„
}
```

## ë°©ì–¸ ë²ˆë“¤ êµ¬ì„±

### DatabaseType ì—´ê±°í˜•ì— ì¶”ê°€

```java
// jinx-core/src/main/java/org/jinx/migration/DatabaseType.java
public enum DatabaseType {
    MYSQL,
    POSTGRESQL,  // ìƒˆë¡œ ì¶”ê°€
    // ... ê¸°íƒ€ DBë“¤
}
```

### DialectBundle ìƒì„± í—¬í¼

```java
// PostgreSQL ë°©ì–¸ ë²ˆë“¤ ìƒì„± ì˜ˆì‹œ
public static DialectBundle createPostgreSqlBundle() {
    PostgreSqlDialect dialect = new PostgreSqlDialect();

    return DialectBundle.builder(dialect, DatabaseType.POSTGRESQL)
            .sequence(dialect)      // PostgreSQLì€ ì‹œí€€ìŠ¤ ì§€ì›
            .liquibase(dialect)     // Liquibase ì§€ì›
            .build();
}
```

## VisitorFactory ë“±ë¡

`VisitorFactory.java`ì— ìƒˆë¡œìš´ ë°©ì–¸ ì¼€ì´ìŠ¤ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤:

```java
// jinx-core/src/main/java/org/jinx/migration/VisitorFactory.java
public final class VisitorFactory {
    public static VisitorProviders forBundle(DialectBundle bundle) {
        var db = bundle.databaseType();
        var ddl = bundle.ddl();

        switch (db) {
            case MYSQL -> {
                // ê¸°ì¡´ MySQL ì½”ë“œ
            }
            case POSTGRESQL -> {  // ìƒˆë¡œ ì¶”ê°€
                Supplier<TableVisitor> tableV =
                        () -> new PostgreSqlMigrationVisitor(null, ddl);

                Function<DiffResult.ModifiedEntity, TableContentVisitor> contentV =
                        me -> new PostgreSqlMigrationVisitor(me, ddl);

                // PostgreSQLì€ ì‹œí€€ìŠ¤ ì§€ì›
                Optional<Supplier<SequenceVisitor>> seqV = bundle.sequence().map(seqDialect ->
                        (Supplier<SequenceVisitor>) () -> new PostgreSqlSequenceVisitor(seqDialect)
                );

                // TableGeneratorëŠ” ì˜µì…˜ (PostgreSQLì€ ì‹œí€€ìŠ¤ë¥¼ ì„ í˜¸)
                var tgOpt = bundle.tableGenerator().map(tgDialect ->
                        (Supplier<TableGeneratorVisitor>) () -> new PostgreSqlTableGeneratorVisitor(tgDialect)
                );

                return new VisitorProviders(tableV, contentV, seqV, tgOpt);
            }
            default -> throw new IllegalArgumentException("Unsupported database type: " + db);
        }
    }
}
```

## CLI í†µí•©

`MigrateCommand.java`ì˜ `resolveDialects` ë©”ì„œë“œì— ì¶”ê°€í•©ë‹ˆë‹¤:

```java
// jinx-cli/src/main/java/org/jinx/cli/MigrateCommand.java
private DialectBundle resolveDialects(String name) {
    return switch (name.toLowerCase()) {
        case "mysql" -> {
            MySqlDialect mysql = new MySqlDialect();
            yield DialectBundle.builder(mysql, DatabaseType.MYSQL)
                    .identity(mysql)
                    .tableGenerator(mysql)
                    .build();
        }
        case "postgresql", "postgres" -> {  // ìƒˆë¡œ ì¶”ê°€
            PostgreSqlDialect postgres = new PostgreSqlDialect();
            yield DialectBundle.builder(postgres, DatabaseType.POSTGRESQL)
                    .sequence(postgres)      // ì‹œí€€ìŠ¤ ì§€ì›
                    .liquibase(postgres)     // Liquibase ì§€ì›
                    .build();
        }
        default -> throw new IllegalArgumentException("Unsupported dialect: " + name);
    };
}
```

## í…ŒìŠ¤íŠ¸ ì‘ì„±

### 1. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

ê° ì»´í¬ë„ŒíŠ¸ë³„ë¡œ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í•©ë‹ˆë‹¤:

```java
// PostgreSqlDialectTest.java
@Test
@DisplayName("PostgreSQL ì»¬ëŸ¼ ì •ì˜ SQL ìƒì„±")
void testColumnDefinitionSql() {
    PostgreSqlDialect dialect = new PostgreSqlDialect();

    ColumnModel column = ColumnModel.builder()
            .columnName("username")
            .javaType("java.lang.String")
            .length(255)
            .isNullable(false)
            .build();

    String sql = dialect.getColumnDefinitionSql(column);
    assertThat(sql).isEqualTo("\"username\" VARCHAR(255) NOT NULL");
}

@Test
@DisplayName("PostgreSQL ì‹œí€€ìŠ¤ ìƒì„± SQL")
void testCreateSequenceSql() {
    PostgreSqlDialect dialect = new PostgreSqlDialect();

    SequenceModel sequence = SequenceModel.builder()
            .sequenceName("user_id_seq")
            .initialValue(1)
            .allocationSize(1)
            .build();

    String sql = dialect.getCreateSequenceSql(sequence);
    assertThat(sql).isEqualTo("CREATE SEQUENCE \"user_id_seq\";\n");
}
```

### 2. í†µí•© í…ŒìŠ¤íŠ¸

```java
// PostgreSqlIntegrationTest.java
@Test
@DisplayName("PostgreSQL ì „ì²´ ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒì„± í…ŒìŠ¤íŠ¸")
void testFullMigrationGeneration() {
    // ì—”í‹°í‹° ëª¨ë¸ ìƒì„±
    EntityModel entity = createTestEntity();

    // ë°©ì–¸ ë²ˆë“¤ ìƒì„±
    DialectBundle bundle = createPostgreSqlBundle();

    // ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒì„±
    MigrationGenerator generator = new MigrationGenerator(bundle);
    DiffResult diff = createTestDiff(entity);

    String sql = generator.generateSql(diff);

    // ìƒì„±ëœ SQL ê²€ì¦
    assertThat(sql).contains("CREATE TABLE");
    assertThat(sql).contains("VARCHAR");
    assertThat(sql).doesNotContain("AUTO_INCREMENT"); // PostgreSQLì€ SERIAL ì‚¬ìš©
}
```

### 3. í•„ìˆ˜ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€

**ë°˜ë“œì‹œ ë‹¤ìŒ ì˜ì—­ë“¤ì„ í…ŒìŠ¤íŠ¸í•´ì•¼ í•©ë‹ˆë‹¤:**

1. **ì‹ë³„ì ì •ì±… í…ŒìŠ¤íŠ¸**
   - ìµœëŒ€ ê¸¸ì´ ì œí•œ
   - ì¸ìš© ë¬¸ë²•
   - ëŒ€ì†Œë¬¸ì ì •ê·œí™”
   - ì˜ˆì•½ì–´ ê²€ì¦

2. **íƒ€ì… ë§¤í•‘ í…ŒìŠ¤íŠ¸**
   - ëª¨ë“  Java íƒ€ì…ì˜ SQL íƒ€ì… ë§¤í•‘
   - ê¸¸ì´, ì •ë°€ë„, ìŠ¤ì¼€ì¼ ì²˜ë¦¬
   - ê¸°ë³¸ê°’ ì²˜ë¦¬

3. **DDL ìƒì„± í…ŒìŠ¤íŠ¸**
   - CREATE TABLE
   - ALTER TABLE (ADD/DROP/MODIFY COLUMN)
   - ì œì•½ì¡°ê±´ (PK, FK, UNIQUE, CHECK)
   - ì¸ë±ìŠ¤

4. **íŠ¹í™” ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸**
   - ì‹œí€€ìŠ¤ (ì§€ì›í•˜ëŠ” ê²½ìš°)
   - Identity/Serial ì»¬ëŸ¼
   - TableGenerator (í•„ìš”í•œ ê²½ìš°)

## ì‹¤ì œ ì˜ˆì‹œ: PostgreSQL ë°©ì–¸ ì¶”ê°€

ë‹¤ìŒì€ PostgreSQL ë°©ì–¸ì„ ì¶”ê°€í•˜ëŠ” ì‹¤ì œ ë‹¨ê³„ë³„ ì²´í¬ë¦¬ìŠ¤íŠ¸ì…ë‹ˆë‹¤:

### ë‹¨ê³„ 1: ê¸°ë³¸ êµ¬ì¡° ìƒì„±

```bash
# 1. íŒ¨í‚¤ì§€ ë””ë ‰í† ë¦¬ ìƒì„±
mkdir -p jinx-core/src/main/java/org/jinx/migration/dialect/postgresql
mkdir -p jinx-core/src/test/java/org/jinx/migration/dialect/postgresql

# 2. ê¸°ë³¸ í´ë˜ìŠ¤ íŒŒì¼ë“¤ ìƒì„±
touch jinx-core/src/main/java/org/jinx/migration/dialect/postgresql/PostgreSqlDialect.java
touch jinx-core/src/main/java/org/jinx/migration/dialect/postgresql/PostgreSqlJavaTypeMapper.java
touch jinx-core/src/main/java/org/jinx/migration/dialect/postgresql/PostgreSqlValueTransformer.java
touch jinx-core/src/main/java/org/jinx/migration/dialect/postgresql/PostgreSqlMigrationVisitor.java
```

### ë‹¨ê³„ 2: ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„

1. `PostgreSqlJavaTypeMapper` êµ¬í˜„
2. `PostgreSqlValueTransformer` êµ¬í˜„
3. `PostgreSqlDialect` ë©”ì¸ í´ë˜ìŠ¤ êµ¬í˜„
4. `PostgreSqlMigrationVisitor` êµ¬í˜„

### ë‹¨ê³„ 3: ì‹œìŠ¤í…œ í†µí•©

1. `DatabaseType.POSTGRESQL` ì¶”ê°€
2. `VisitorFactory`ì— PostgreSQL ì¼€ì´ìŠ¤ ì¶”ê°€
3. `MigrateCommand.resolveDialects()`ì— ì¶”ê°€

### ë‹¨ê³„ 4: í…ŒìŠ¤íŠ¸ ì‘ì„±

1. ê° í´ë˜ìŠ¤ë³„ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‘ì„±
2. í†µí•© í…ŒìŠ¤íŠ¸ ì‘ì„±
3. ì‹¤ì œ PostgreSQL DDL ê²€ì¦

### ë‹¨ê³„ 5: ë¬¸ì„œí™”

1. ì§€ì› DB ëª©ë¡ì— PostgreSQL ì¶”ê°€
2. ì‚¬ìš©ë²• ë¬¸ì„œ ì—…ë°ì´íŠ¸
3. ì´ ê¸°ì—¬ ê°€ì´ë“œ ì—…ë°ì´íŠ¸

## ì£¼ì˜ì‚¬í•­

### í•„ìˆ˜ ê³ ë ¤ì‚¬í•­

1. **ì˜ˆì•½ì–´ ì²˜ë¦¬**: ê° DBì˜ ì˜ˆì•½ì–´ ëª©ë¡ì„ ì •í™•íˆ íŒŒì•…
2. **ì‹ë³„ì ê¸¸ì´**: DBë³„ ìµœëŒ€ ì‹ë³„ì ê¸¸ì´ ì œí•œ ì¤€ìˆ˜
3. **íƒ€ì… ë§¤í•‘**: Java íƒ€ì…ê³¼ SQL íƒ€ì…ì˜ ì •í™•í•œ ë§¤í•‘
4. **ë¬¸ë²• ì°¨ì´**: CREATE TABLE, ALTER TABLE ë“±ì˜ ë¬¸ë²• ì°¨ì´
5. **ì œì•½ì¡°ê±´**: PK, FK, UNIQUE, CHECK ì œì•½ì¡°ê±´ ë¬¸ë²•
6. **íŠ¹í™” ê¸°ëŠ¥**: ì‹œí€€ìŠ¤, ìë™ ì¦ê°€ ì»¬ëŸ¼ ë“±ì˜ ì§€ì› ì—¬ë¶€

### í…ŒìŠ¤íŠ¸ í•„ìˆ˜ì‚¬í•­

1. **DDL ë¬¸ë²• ê²€ì¦**: ìƒì„±ëœ SQLì´ ì‹¤ì œ DBì—ì„œ ì‹¤í–‰ ê°€ëŠ¥í•œì§€ í™•ì¸
2. **ë§ˆì´ê·¸ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸**: ì‹¤ì œ ìŠ¤í‚¤ë§ˆ ë³€ê²½ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸
3. **ì—­í˜¸í™˜ì„±**: ê¸°ì¡´ ì½”ë“œì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠëŠ”ì§€ í™•ì¸
4. **ì—ëŸ¬ ì¼€ì´ìŠ¤**: ì˜ëª»ëœ ì„¤ì •ì´ë‚˜ ì§€ì›í•˜ì§€ ì•ŠëŠ” ê¸°ëŠ¥ì— ëŒ€í•œ ì—ëŸ¬ ì²˜ë¦¬

### ì„±ëŠ¥ ê³ ë ¤ì‚¬í•­

1. **ì§€ì—° ì´ˆê¸°í™”**: ë¬´ê±°ìš´ ë¦¬ì†ŒìŠ¤ëŠ” í•„ìš”í•  ë•Œë§Œ ì´ˆê¸°í™”
2. **ìºì‹±**: ìì£¼ ì‚¬ìš©ë˜ëŠ” ì •ë³´ëŠ” ìºì‹±
3. **ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±**: ë¶ˆí•„ìš”í•œ ê°ì²´ ìƒì„± ìµœì†Œí™”

---

ìƒˆë¡œìš´ ë°ì´í„°ë² ì´ìŠ¤ ë°©ì–¸ì„ ì¶”ê°€í•˜ëŠ” ê²ƒì€ ë³µì¡í•˜ì§€ë§Œ, Jinxì˜ SPI ì•„í‚¤í…ì²˜ ë•ë¶„ì— ì²´ê³„ì ìœ¼ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê°€ì´ë“œì˜ ë‹¨ê³„ë¥¼ ë”°ë¼í•˜ë©´ì„œ ê¸°ì¡´ MySQL êµ¬í˜„ì²´ë¥¼ ì°¸ê³ í•˜ë©´ ì„±ê³µì ìœ¼ë¡œ ìƒˆë¡œìš´ ë°©ì–¸ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

**ê¸°ì—¬ ì‹œ ë°˜ë“œì‹œ ê¸°ì–µí•  ì :**
- ëª¨ë“  ë³€ê²½ì‚¬í•­ì— ëŒ€í•œ **í¬ê´„ì ì¸ í…ŒìŠ¤íŠ¸ ì‘ì„±**
- ì‹¤ì œ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ **DDL ê²€ì¦**
- **ë¬¸ì„œí™” ì—…ë°ì´íŠ¸**
- **ì½”ë“œ ë¦¬ë·°** ìš”ì²­
- CI ë‹¨ê³„ì—ì„œ ëª¨ë“  í…ŒìŠ¤íŠ¸ê°€ í†µê³¼ë˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ë¨¸ì§€ëŠ” ê±°ì ˆë©ë‹ˆë‹¤

ì—¬ëŸ¬ë¶„ì˜ ê¸°ì—¬ê°€ Jinxë¥¼ ë”ìš± ê°•ë ¥í•œ ë„êµ¬ë¡œ ë§Œë“¤ì–´ ì¤„ ê²ƒì…ë‹ˆë‹¤!